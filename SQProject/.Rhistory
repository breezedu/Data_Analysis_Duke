#X11()
gene.mean[i] <- mean(hw2_genes[,i])
gene.std[i] <- sd(hw2_genes[,i])
gene.standardized <- (hw2_genes[,i]-gene.mean[i])/gene.std[i]
qqnorm(hw2_genes[,i],main=paste("QQ plot of",i))
qqline(hw2_genes[,i], col = 2)
qqnorm(gene.standardized,main=paste("standardized QQ plot of",i))
qqline(gene.standardized, col = 2)
}
## plot all 20 genes in one graph
par(geneQQ.par)
#################################################################################
## Q1.d
## Project one gene to the quantiles of a standard normal,
## and plot the same quantile-quantile
## plot with the quantile normalized data.
## How does quantile normalization impact the quantilequantileplots?
## Are outliers controlled?
#################################################################################
## plot gene 1-3
X11()
gene.normalized <- normalize.quantiles(hw2_genes)
qqNorm_qqStan.par <- par(mfrow=c(3, 2))
for(i in 1:3){
## X11()
qqnorm(hw2_genes[,i],main=paste("Quantitles-quantitle plot of gene",i))
qqline(hw2_genes[,i], col = 2)
#######################################
## X11()
qqnorm(gene.normalized[,i],main=paste("Normalized QQ plot of gene",i))
qqline(gene.normalized[,i], col = 2)
}
par(qqNorm_qqStan.par)
#########################################
## plot gene 4-6
X11()
gene.normalized <- normalize.quantiles(hw2_genes)
qqNorm_qqStan.par <- par(mfrow=c(3, 2))
for(i in 4:6){
## X11()
qqnorm(hw2_genes[,i],main=paste("Quantitles-quantitle plot of gene",i))
qqline(hw2_genes[,i], col = 2)
#######################################
## X11()
qqnorm(gene.normalized[,i],main=paste("Normalized QQ plot of gene",i))
qqline(gene.normalized[,i], col = 2)
}
par(qqNorm_qqStan.par)
#########################################
## plot gene 7-10
X11()
gene.normalized <- normalize.quantiles(hw2_genes)
qqNorm_qqStan.par <- par(mfrow=c(2, 2))
for(i in 7:8){
## X11()
qqnorm(hw2_genes[,i],main=paste("Quantitles-quantitle plot of gene",i))
qqline(hw2_genes[,i], col = 2)
#######################################
## X11()
qqnorm(gene.normalized[,i],main=paste("Normalized QQ plot of gene",i))
qqline(gene.normalized[,i], col = 2)
}
par(qqNorm_qqStan.par)
#######################################
## Plot gene 9-10
X11()
gene.normalized <- normalize.quantiles(hw2_genes)
qqNorm_qqStan.par <- par(mfrow=c(2, 2))
for(i in 9:10){
## X11()
qqnorm(hw2_genes[,i],main=paste("Quantitles-quantitle plot of gene",i))
qqline(hw2_genes[,i], col = 2)
#######################################
## X11()
qqnorm(gene.normalized[,i],main=paste("Normalized QQ plot of gene",i))
qqline(gene.normalized[,i], col = 2)
}
par(qqNorm_qqStan.par)
#################################################################################
## Q1.e
## Plot the covariance of the genes. Which genes appear to covary?
##
#################################################################################
X11()
covHeat.par <- par(mfrow=c(3, 1))
gene.covar = cov(hw2_genes)
gene.corr = cov2cor(gene.covar)
## X11()
heatmap(gene.covar, main=paste("gene cov"))
X11()
heatmap(gene.corr, main=paste("covariance of 10 genes"))
X11()
pheatmap(gene.corr, main=paste("pheatmap of gene.corr"))
par(covHeat.par)
#################################################################################
## end of question one!
#################################################################################
#################################################################################
#################################################################################
## Question 2  Finding eQTLs.
## Download a corresponding set of (simulated) genotypes from the course website
################################################################################
#################################################################################
## Question 2.a
##  Which gene-SNP pairs appear to be associated ?
## here we plot correlation heatmap of all 10 genes' SNPs
#################################################################################
X11()
geneSNP.cor <- cor(hw2_genes,SNP)
pheatmap(geneSNP.cor, main=paste("geneSNP pheatmap"))
X11()
heatmap(geneSNP.cor, main=paste("geneSNP heatmap"))
#################################################################################
## Q2.b
## Choose one associated gene-SNP pair,
## and one pair that does not appear associated.
## For both pairs, plot the SNP (x-axis) versus gene (y-axis).
## Overlay on top of this the best fit linear regression model parameters ß.
## Include this figure in your solutions.
## base on the pheatmap in Q2.a, here we wil choose gene#3
m1 <- lm(hw2_genes[,3] ~ SNP[,2])
summary(m1)
m2 <- lm(hw2_genes[,3] ~ SNP[,5])
summary(m2)
X11()
b1 = cov(hw2_genes[,3],SNP[,2])/var(SNP[,2])
plot(SNP[,2],hw2_genes[,3],xlab="SNP 2",ylab="Gene 3 expression",main=paste("coefficient=",b1))
abline(m1,col=2)
X11()
b2 = cov(hw2_genes[,3],SNP[,5])/var(SNP[,5])
plot(SNP[,5],hw2_genes[,3],xlab="SNP 5",ylab="Gene 3 expression",main=paste("coefficient=",b2))
abline(m2,col=2)
#################################################################################
## Q2.c
## What are the RSS for both of the pairs you have chosen?
## What is the r^2 value?
#################################################################################
RSS1 = sum((m1$residuals)^2)
RSS2 = sum((m2$residuals)^2)
r1 = summary(m1)$r.squared
r2 = summary(m2)$r.squared
## printout the rss1 and rss2 values, as well as r1 and r2 values
RSS1
r1
RSS2
r2
#################################################################################
##################################################################################
## END of Question 2
##################################################################################
SNP = cbind(rep(x=1,500),SNP)
ans=lars(SNP[,],hw2_genes[,1],type="lar",normalize=TRUE)
summary(ans)
coef(ans)
plot(ans)
plot(ans,xvar="step")
X11()
plot(ans)
X11()
plot(ans,xvar="step")
summary(ans)
r=linearRidgeGenotypes("SNP.txt","expression.txt")
coef(ans)
## summary ANS
summary(ans)
summary(ans)
r=linearRidgeGenotypes("SNP.txt","expression.txt")
library(lars)
q()
soft.pkgs <- c("AnnotationHub",
"BSgenome",
"Biobase",
"Biostrings",
"GEOquery",
"GenomeInfoDb",
"GenomicFeatures",
"GenomicRanges",
"IRanges",
"Rsamtools",
"ShortRead",
"biomaRt",
"minfi",
"oligo",
"rtracklayer")
data.pkgs <- c("ALL",
"BSgenome.Hsapiens.UCSC.hg19",
"BSgenome.Scerevisiae.UCSC.sacCer2",
"TxDb.Hsapiens.UCSC.hg19.knownGene",
"airway",
"hgu95av2.db",
"leeBamViews",
"leukemiasEset",
"minfiData",
"yeastRNASeq",
"zebrafishRNASeq")
biocLite(c(soft.pkgs, data.pkgs))
biocLite(c(soft.pkgs, data.pkgs))
soft.pkgs <- c("AnnotationHub",
"BSgenome",
"Biobase",
"Biostrings",
"GEOquery",
"GenomeInfoDb",
"GenomicFeatures",
"GenomicRanges",
"IRanges",
"Rsamtools",
"ShortRead",
"biomaRt",
"minfi",
"oligo",
"rtracklayer")
data.pkgs <- c("ALL",
"BSgenome.Hsapiens.UCSC.hg19",
"BSgenome.Scerevisiae.UCSC.sacCer2",
"TxDb.Hsapiens.UCSC.hg19.knownGene",
"airway",
"hgu95av2.db",
"leeBamViews",
"leukemiasEset",
"minfiData",
"yeastRNASeq",
"zebrafishRNASeq")
biocLite(c(soft.pkgs, data.pkgs))
source("http://bioconductor.org/biocLite.R")
biocLite()
biocLite(c(soft.pkgs, data.pkgs))
plotRanges <- function(x, xlim = x, main = deparse(substitute(x)),
+ col = "black", sep = 0.5, ..)
+ { height <-1
+ if (is(xlim, "Ranges"))
+ xlim <- c(min(start(xlim)), max(end(xlim)))
+ bins <- disjointBins(IRanges(start(x), end(x) +1))
+ plot.new()
+ plot.window(xlim, c(0, max(bins)*(height + sep)))
+ ybottom <- bins * (sep + height) - height
+ rect(start(x) - 0.5, ybottom, end(x) + 0.5, ybottom + height, col = col, ...)
+ title(main)
+ axis(a)
+ }
plotRanges <- function(x, xlim = x, main = deparse(substitute(x)),
+ col = "black", sep = 0.5, ..)
+ { height <-1
+ if (is(xlim, "Ranges"))
+ xlim <- c(min(start(xlim)), max(end(xlim)))
+ bins <- disjointBins(IRanges(start(x), end(x) +1))
+ plot.new()
+ plot.window(xlim, c(0, max(bins)*(height + sep)))
+ ybottom <- bins * (sep + height) - height
+ rect(start(x) - 0.5, ybottom, end(x) + 0.5, ybottom + height, col = col, ...)
+ title(main)
+ axis(a)
+ }
library(GenomicRanges)
library(IRanges)
library(IRanges)
library(GenomicRanges)
biocLite
biocLite()
library(IRanges)
library(GRanges)
library(IRanges)
library(IRanges)
library(IRanges)
library(BiocGenerics)
library(IRanges)
biocLite()
biocLite()
source("http://bioconductor.org/biocLite.R")
biocLite()
library(IRanges)
library(GenomicRanges)
library(GenomicRanges)
source("http://bioconductor.org/biocLite.R")
biocLite()
library(IRanges)
library(GenomicRanges)
library(GenomicRanges)
library(GenomeInfoDb)
soft.pkgs <- c("AnnotationHub",
"BSgenome",
"Biobase",
"Biostrings",
"GEOquery",
"GenomeInfoDb",
"GenomicFeatures",
"GenomicRanges",
"IRanges",
"Rsamtools",
"ShortRead",
"biomaRt",
"minfi",
"oligo",
"rtracklayer")
data.pkgs <- c("ALL",
"BSgenome.Hsapiens.UCSC.hg19",
"BSgenome.Scerevisiae.UCSC.sacCer2",
"TxDb.Hsapiens.UCSC.hg19.knownGene",
"airway",
"hgu95av2.db",
"leeBamViews",
"leukemiasEset",
"minfiData",
"yeastRNASeq",
"zebrafishRNASeq")
biocLite(c(soft.pkgs, data.pkgs))
library(GenomicRanges)
library(IRanges)
table <- read.table("exon_level_process_v2.txt")
table <- read.table("D:/GitHub Repositories/DataStats/Data_Analysis_Duke/SQProjectexon_level_process_v2.txt")
table <- read.table("D:/GitHubRepositories/DataStats/Data_Analysis_Duke/SQProjectexon_level_process_v2.txt")
table <- read.table("D:/GitHubRepositories/DataStats/Data_Analysis_Duke/SQProject/exon_level_process_v2.txt")
## assign column names
colnames(table) <- c("chr", "gene", "dom", "subdom", "exon", "gene.dom", 
             "gene.dom.subdom", 
             "envarp",    # pass
             "envarpf",   # pass functional
             "envarpfr",  # pass functional rare
             "emutr")     # mutation rate 
## attract data from the original table??
table<-within(table,envarpfc<-envarpf-envarpfr)#y
table<-within(table,gene<-factor(gene))
table<-within(table,gene.dom<-factor(gene.dom))
table<-within(table,gene.dom.subdom<-factor(gene.dom.subdom))
#table<-table[1:100,]
#for the use of counting number of gene
sumenvarp<-aggregate(table$envarp, by=list(Category=table$gene), FUN=sum)
sumenvarpfc<-aggregate(table$envarpfc, by=list(Category=table$gene), FUN=sum)[,2]
## simplify table1
table1<-data.frame(cbind(sumenvarp,sumenvarpfc))
## assign column names to table1
colnames(table1)<-c("gene","sumenvarp","sumenvarpfc")
library("Matrix")
library("lme4")
library("rstan")
## For execution on a local, multicore CPU with excess RAM we recommend calling
## rstan_options(auto_write = TRUE)
## options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
gene_code<-"
data{   #get the data we have
int <lower=0> N; #number of obs
int <lower=0> J; #number of gene level 
int <lower=1,upper=J> gene[N];
vector[N] x;  #x
int <lower=0> y[N] ; #y
}
parameters{ #specify the parameter we want to know 
vector[J] a;  #random intercept when gene is the level 
real <lower=0> sigma_a;  #variance of intercept
real <lower=0> sigma_epsilon; #variance of dispersion
real beta;    #common slope;
vector[N] epsilon_raw;
}
transformed parameters{ #specify the model we will use 
vector[N] lambda;
vector[N] epsilon; #amount of dispersion 
for (i in 1:N) 
     epsilon[i]<-sigma_epsilon*epsilon_raw[i];
for (i in 1:N) 
     lambda[i] <- beta*x[i]+a[gene[i]]+epsilon[i];#specify the group
}
model { #give the prior distribution
  beta ~ normal(0,10);
  a ~ normal(0, sigma_a);
  epsilon_raw~normal(0,1);
  y ~ poisson_log(lambda); #y and y_hat should have same type 
}
"
N<-dim(table)[1]
J<-dim(table1)[1]
gene<-as.numeric(table$gene)
genelevel<-length(unique(gene))
index<-match(gene, unique(gene)) 
M1_table<-list(N=N, J=J, y=table$envarpfc,
x=table$envarp,gene=index)
fit1 <- stan(model_code=gene_code, data=M1_table, iter=100, chains=4)
fit1 <- stan(model_code=gene_code, data=M1_table, iter=100, chains=4)
q()
table <- read.table("D:/GitHubRepositories/DataStats/Data_Analysis_Duke/SQProject/exon_level_process_v2.txt")
## assign column names
colnames(table) <- c("chr", "gene", "dom", "subdom", "exon", "gene.dom", 
             "gene.dom.subdom", 
             "envarp",    # pass
             "envarpf",   # pass functional
             "envarpfr",  # pass functional rare
             "emutr")     # mutation rate 
## attract data from the original table??
table<-within(table,envarpfc<-envarpf-envarpfr)#y
table<-within(table,gene<-factor(gene))
table<-within(table,gene.dom<-factor(gene.dom))
table<-within(table,gene.dom.subdom<-factor(gene.dom.subdom))
table<-table[1:1000,]
sumenvarp<-aggregate(table$envarp, by=list(Category=table$gene), FUN=sum)
sumenvarpfc<-aggregate(table$envarpfc, by=list(Category=table$gene), FUN=sum)[,2]
## simplify table1
table1<-data.frame(cbind(sumenvarp,sumenvarpfc))
## assign column names to table1
colnames(table1)<-c("gene","sumenvarp","sumenvarpfc")
library("Matrix")
library("lme4")
library("rstan")
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
gene_code<-"
data{   #get the data we have
int <lower=0> N; #number of obs
int <lower=0> J; #number of gene level 
int <lower=1,upper=J> gene[N];
vector[N] x;  #x
int <lower=0> y[N] ; #y
}
parameters{ #specify the parameter we want to know 
vector[J] a;  #random intercept when gene is the level 
real <lower=0> sigma_a;  #variance of intercept
real <lower=0> sigma_epsilon; #variance of dispersion
real beta;    #common slope;
vector[N] epsilon_raw;
}
transformed parameters{ #specify the model we will use 
vector[N] lambda;
vector[N] epsilon; #amount of dispersion 
for (i in 1:N) 
     epsilon[i]<-sigma_epsilon*epsilon_raw[i];
for (i in 1:N) 
     lambda[i] <- beta*x[i]+a[gene[i]]+epsilon[i];#specify the group
}
model { #give the prior distribution
  beta ~ normal(0,10);
  a ~ normal(0, sigma_a);
  epsilon_raw~normal(0,1);
  y ~ poisson_log(lambda); #y and y_hat should have same type 
}
"
N<-dim(table)[1]
J<-dim(table1)[1]
gene<-as.numeric(table$gene)
genelevel<-length(unique(gene))
index<-match(gene, unique(gene)) 
M1_table<-list(N=N, J=J, y=table$envarpfc,
x=table$envarp,gene=index)
fit1 <- stan(model_code=gene_code, data=M1_table, iter=1000, chains=4)
fit1 <- stan(model_code=gene_code, data=M1_table, iter=2000, chains=4)
fit1 <- stan(model_code=gene_code, data=M1_table, iter=3000, chains=4)
fit1 <- stan(model_code=gene_code, data=M1_table, iter=5000, chains=4)
table <- read.table("D:/GitHubRepositories/DataStats/Data_Analysis_Duke/SQProject/exon_level_process_v2.txt")
##  table<-read.table("C:/Users/shuaiqi/Desktop/duke/Andrew/data/for_asa/other_stuff/exon_level_process_v3.txt")
## assign column names
colnames(table) <- c("chr", "gene", "dom", "subdom", "exon", "gene.dom", 
             "gene.dom.subdom", 
             "envarp",    # pass
             "envarpf",   # pass functional
             "envarpfr",  # pass functional rare
             "emutr")     # mutation rate 
## attract data from the original table??
table<-within(table,envarpfc<-envarpf-envarpfr)#y
table<-within(table,gene<-factor(gene))
table<-within(table,gene.dom<-factor(gene.dom))
table<-within(table,gene.dom.subdom<-factor(gene.dom.subdom))
# table<-table[1:1000,]
# for the use of counting number of gene
sumenvarp<-aggregate(table$envarp, by=list(Category=table$gene), FUN=sum)
sumenvarpfc<-aggregate(table$envarpfc, by=list(Category=table$gene), FUN=sum)[,2]
## simplify table1
table1<-data.frame(cbind(sumenvarp,sumenvarpfc))
## assign column names to table1
colnames(table1)<-c("gene","sumenvarp","sumenvarpfc")
gene_code<-"
data{   #get the data we have
int <lower=0> N; #number of obs
int <lower=0> J; #number of gene level 
int <lower=1,upper=J> gene[N];
vector[N] x;  #x
int <lower=0> y[N] ; #y
}
parameters{ #specify the parameter we want to know 
vector[J] a;  #random intercept when gene is the level 
real <lower=0> sigma_a;  #variance of intercept
real <lower=0> sigma_epsilon; #variance of dispersion
real beta;    #common slope;
vector[N] epsilon_raw;
}
transformed parameters{ #specify the model we will use 
vector[N] lambda;
vector[N] epsilon; #amount of dispersion 
for (i in 1:N) 
     epsilon[i]<-sigma_epsilon*epsilon_raw[i];
for (i in 1:N) 
     lambda[i] <- beta*x[i]+a[gene[i]]+epsilon[i];#specify the group
}
model { #give the prior distribution
  beta ~ normal(0,10);
  a ~ normal(0, sigma_a);
  epsilon_raw~normal(0,1);
  y ~ poisson_log(lambda); #y and y_hat should have same type 
}
"
N<-dim(table)[1]
J<-dim(table1)[1]
gene<-as.numeric(table$gene)
genelevel<-length(unique(gene))
index<-match(gene, unique(gene)) 
M1_table<-list(N=N, J=J, y=table$envarpfc,
x=table$envarp,gene=index)
fit1 <- stan(model_code=gene_code, data=M1_table, iter=2000, chains=4)
fit1 <- stan(model_code=gene_code, data=M1_table, iter=200, chains=4)
q()
setwd("D:/GitHubRepositories/DataStats/Data_Analysis_Duke/SQProject/")
library("rstan")
source("1106_dataManage_Poisson.R")
q()
